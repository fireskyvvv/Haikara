using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml.Linq;
using Haikara.Runtime;
using Haikara.Runtime.Bindable;
using Haikara.Runtime.View;
using Haikara.Shared;
using HaikaraDev.Tests.Common;
using HaikaraDev.Tests.Common.Editor;
using NUnit.Framework;
using UnityEditor;
using UnityEngine.UIElements;
using TestView = HaikaraDev.Tests.Common.Editor.View.TestView;
using View_TestView = HaikaraDev.Tests.Common.Editor.View.TestView;

namespace HaikaraDev.Tests.EditMode
{
    public class ViewGeneratedCodeTest
    {
        private List<(XElement element, int index)> _viewUxmlElements;

        [SetUp]
        public void Setup()
        {
            var relativePath = AssetDatabase.GetAssetPath(TestFilesUtil.TestViewVisualTreeAsset);
            var fullPath = Path.GetFullPath(relativePath);
            var uxmlContent = File.ReadAllText(fullPath);

            var doc = XDocument.Parse(uxmlContent);
            const string engineNamespace = "UnityEngine.UIElements";
            _viewUxmlElements = doc.Descendants()
                .Where(e => e.Name.Namespace == engineNamespace)
                .Select((x, index) => (element: x, index: index))
                .ToList();
        }

        [Test]
        public void View_GetGuid_AfterSourceGeneration_ReturnsCorrectAssetGuid()
        {
            var expectedGuid = AssetDatabase.AssetPathToGUID(TestFilesUtil.TestViewFileAssetPath);

            var view = new View_TestView();
            var actualGuid = view.GetGuid();

            Assert.AreEqual(expectedGuid, actualGuid, "GetGuid() method did not return the correct GUID.");
        }

        [Test]
        public void View_AssetReferenceMode_AfterSourceGeneration_MatchesAttributeValue()
        {
            var targetType = TestFilesUtil.TestViewType;

            var haikaraUIAttribute = targetType.GetCustomAttribute<HaikaraUIAttribute>();
            Assert.IsNotNull(haikaraUIAttribute, "HaikaraUIAttribute not found on EditModeTestView.");

            var expectedMode = haikaraUIAttribute.ReferenceMode;

            var view = new View_TestView();

            var actualMode = view.AssetReferenceMode;

            Assert.AreEqual(expectedMode, actualMode,
                "The generated AssetReferenceMode property does not match the value from the HaikaraUIAttribute.");
        }

        /// <summary>
        /// Verifies that the UxmlGuid generated by the SourceGenerator is correct.
        /// </summary>
        [Test]
        public void View_UxmlGuidField_AfterSourceGeneration_HasCorrectUxmlFileGuid()
        {
            var expectedGuid = AssetDatabase.AssetPathToGUID(TestFilesUtil.TestViewFileAssetPath);
            var guidField = TestFilesUtil.TestViewType.GetField("UxmlGuid", BindingFlags.Public | BindingFlags.Static);
            Assert.IsNotNull(guidField, "public const string 'UxmlGuid' was not found.");
            var actualGuid = guidField.GetValue(null) as string;

            Assert.AreEqual(expectedGuid.ToLower(), actualGuid?.ToLower());
        }

        /// <summary>
        /// Verifies that the ElementNames struct, generated by the SourceGenerator, contains all element names from the UXML file.
        /// </summary>
        [Test]
        public void View_ElementNames_AfterSourceGeneration_ContainsAllAndOnlyUxmlElements()
        {
            // Check if the ElementNames struct is generated correctly.
            var elementNamesType = TestFilesUtil.TestViewType.GetNestedType("ElementNames", BindingFlags.NonPublic);
            Assert.IsNotNull(elementNamesType,
                "private struct 'ElementNames' was not found. Source Generation might have failed."
            );

            var expectedElementNamesFieldNames = ElementNameUtil.GetElementNameFields(_viewUxmlElements)
                .ToDictionary(x => x.fieldName, x => false);

            // Check if the fields in ElementNames are generated completely and correctly (no extras, no omissions).
            var actualElementNamesFields = elementNamesType.GetFields(BindingFlags.Public | BindingFlags.Static);

            // Check if the number of elements from UXML matches the number of fields in ElementNames.
            Assert.AreEqual(expectedElementNamesFieldNames.Count, actualElementNamesFields.Length);

            foreach (var actualElementNamesField in actualElementNamesFields)
            {
                var actualFieldName = actualElementNamesField.Name;
                Assert.IsTrue(
                    expectedElementNamesFieldNames.ContainsKey(actualFieldName),
                    // An unexpected element name, not found in the UXML, was generated in ElementNames.
                    "An unexpected element name, not found in the UXML, was generated in ElementNames."
                );

                expectedElementNamesFieldNames[actualFieldName] = true;
            }

            // Check if all expected elements from the UXML are present.
            Assert.IsTrue(
                expectedElementNamesFieldNames.Select(x => x.Value).All(x => x),
                // A required field is missing from the generated ElementNames.
                "A required field is missing from the generated ElementNames."
            );
        }

        [Test]
        public void View_TemplateInfoList_AfterSourceGeneration_ContainsCorrectDataForAllTemplates()
        {
            // Check if the TemplateInfoList struct is generated correctly.
            var templateInfoListType =
                TestFilesUtil.TestViewType.GetNestedType("TemplateInfoList", BindingFlags.NonPublic);
            Assert.IsNotNull(templateInfoListType,
                "private struct 'TemplateInfoList' was not found. Source Generation might have failed."
            );

            var expectedTemplateInfoFields = ElementNameUtil.GetTemplateInfoFields(_viewUxmlElements).ToList();
            var fieldNamesMarks = expectedTemplateInfoFields.ToDictionary(x => x.fieldName, x => false);

            var actualTemplateInfoListFields =
                templateInfoListType.GetFields(BindingFlags.Public | BindingFlags.Static);

            Assert.AreEqual(expectedTemplateInfoFields.Count, actualTemplateInfoListFields.Length,
                // The number of expected TemplateInfoList fields does not match the actual number of fields.
                "The number of expected TemplateInfoList fields does not match the actual number of fields."
            );

            var actualFieldNames = actualTemplateInfoListFields.ToDictionary(
                field => field.Name,
                field => field.GetValue(null) is TemplateInfo ? (TemplateInfo)field.GetValue(null) : default
            );

            foreach (var expectedTemplateInfoField in expectedTemplateInfoFields)
            {
                Assert.IsTrue(actualFieldNames.ContainsKey(expectedTemplateInfoField.fieldName),
                    $"Expected field '{expectedTemplateInfoField.fieldName}' was not found in TemplateInfoList.");

                var actualTemplateInfo = actualFieldNames[expectedTemplateInfoField.fieldName];

                Assert.AreEqual(expectedTemplateInfoField.viewGuid, actualTemplateInfo.ViewGuid,
                    $"viewGuid for '{expectedTemplateInfoField.viewGuid}' is incorrect."
                );
                Assert.AreEqual(expectedTemplateInfoField.templateId, actualTemplateInfo.TemplateId,
                    $"templateId for '{expectedTemplateInfoField.templateId}' is incorrect."
                );

                Assert.AreEqual(expectedTemplateInfoField.elementName, actualTemplateInfo.ElementName.Name,
                    $"elementName for '{expectedTemplateInfoField.elementName}' is incorrect."
                );
            }
        }

        /// <summary>
        /// Verifies that the ElementProperties collection is generated correctly.
        /// </summary>
        [Test]
        public void View_ElementProperties_AfterSourceGeneration_IncludesAllDefinedProperties()
        {
            var view = new View_TestView();
            var actualProperties = view.ElementProperties;

            // A list of all fields that implement IElementProperty.
            var expectedBindableProperties = TestFilesUtil.TestViewType
                .GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static)
                .Where(f => typeof(IElementProperty).IsAssignableFrom(f.FieldType))
                .Select(f => f.GetValue(null) as IElementProperty)
                .ToList();

            // A list of element names from ClickCommand attributes.
            var clickCommandElementNames = TestFilesUtil.TestViewType
                .GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)
                .Where(m => m.GetCustomAttribute<ClickCommandAttribute>() != null)
                .Select(m =>
                {
                    var attr = m.GetCustomAttribute<ClickCommandAttribute>();
                    return attr.TargetElementName;
                })
                .ToList();

            var expectedTotalCount = expectedBindableProperties.Count + clickCommandElementNames.Count;

            // Check if the number of properties in ElementProperties is correct.
            Assert.AreEqual(expectedTotalCount, actualProperties.Count,
                "The total number of generated properties is incorrect."
            );

            // Check if the IBindableProperty collection in ElementProperties is correct.
            var actualBindableProperties = actualProperties.OfType<IBindableProperty>().ToList();
            CollectionAssert.AreEquivalent(expectedBindableProperties, actualBindableProperties,
                "The set of generated BindableProperties is incorrect.");

            // Check if the ManipulatorProperty collection (from ClickCommands) in ElementProperties is correct.
            var actualCommandElementNames = actualProperties.OfType<ManipulatorProperty<VisualElement>>()
                .Select(p => p.ElementNameInfo.ElementName.Name)
                .ToList();

            CollectionAssert.AreEquivalent(clickCommandElementNames, actualCommandElementNames,
                "The set of generated ClickCommand element names is incorrect.");
        }
    }
}